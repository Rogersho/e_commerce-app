-- Helper function to check admin role without recursion (Security Definer bypasses RLS)
create or replace function public.is_admin()
returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
  return exists (
    select 1
    from public.profiles
    where id = auth.uid()
    and role = 'admin'
  );
end;
$$;

-- Create profiles table
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  address text,
  role text default 'customer' check (role in ('customer', 'admin'))
);

alter table public.profiles enable row level security;

drop policy if exists "Public profiles are viewable by everyone" on profiles;
create policy "Public profiles are viewable by everyone"
  on profiles for select
  using ( true );

drop policy if exists "Users can insert their own profile" on profiles;
create policy "Users can insert their own profile"
  on profiles for insert
  with check ( auth.uid() = id );

drop policy if exists "Users can update own profile" on profiles;
create policy "Users can update own profile"
  on profiles for update
  using ( auth.uid() = id );

drop policy if exists "Anyone can view review profiles" on public.profiles;
create policy "Anyone can view review profiles"
  on public.profiles for select
  using (true);

drop policy if exists "Admins can view all profiles" on public.profiles;
create policy "Admins can view all profiles"
  on public.profiles for select
  using ( public.is_admin() );

-- Function to handle new user signup and create profile automatically
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, role)
  values (new.id, new.raw_user_meta_data->>'full_name', 'customer')
  on conflict (id) do nothing;
  return new;
end;
$$;

-- Trigger to automatically create profile for new users
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- Create categories table
create table if not exists public.categories (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  image_url text
);

alter table public.categories enable row level security;

drop policy if exists "Categories are viewable by everyone." on categories;
create policy "Categories are viewable by everyone."
  on categories for select
  using ( true );

drop policy if exists "Admins can insert categories." on categories;
create policy "Admins can insert categories."
  on categories for insert
  with check ( exists ( select 1 from profiles where id = auth.uid() and role = 'admin' ) );
  
drop policy if exists "Admins can update categories." on categories;
create policy "Admins can update categories."
  on categories for update
  using ( exists ( select 1 from profiles where id = auth.uid() and role = 'admin' ) );

-- Create products table
create table if not exists public.products (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  description text,
  price numeric not null,
  discount_price numeric,
  stock integer default 0,
  category_id bigint references public.categories,
  images text[], -- Array of image URLs
  brand text,
  rating numeric default 0,
  review_count integer default 0,
  is_featured boolean default false
);

alter table public.products enable row level security;

drop policy if exists "Products are viewable by everyone." on products;
create policy "Products are viewable by everyone."
  on products for select
  using ( true );

drop policy if exists "Admins can insert products." on products;
create policy "Admins can insert products."
  on products for insert
  with check ( exists ( select 1 from profiles where id = auth.uid() and role = 'admin' ) );

drop policy if exists "Admins can update products." on products;
create policy "Admins can update products."
  on products for update
  using ( exists ( select 1 from profiles where id = auth.uid() and role = 'admin' ) );

-- Create orders table
create table if not exists public.orders (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references public.profiles(id) not null,
  status text default 'pending' check (status in ('pending', 'processing', 'shipped', 'delivered', 'cancelled')),
  total_amount numeric not null,
  shipping_address jsonb,
  phone_number text,
  payment_method text default 'cash_on_delivery',
  payment_status text default 'unpaid'
);

alter table public.orders enable row level security;

drop policy if exists "Users can view their own orders." on orders;
create policy "Users can view their own orders."
  on orders for select
  using ( auth.uid() = user_id );

drop policy if exists "Admins can view all orders." on orders;
create policy "Admins can view all orders."
  on orders for select
  using ( exists ( select 1 from profiles where id = auth.uid() and role = 'admin' ) );

drop policy if exists "Users can insert their own orders." on orders;
create policy "Users can insert their own orders."
  on orders for insert
  with check ( auth.uid() = user_id );

-- Create order_items table
create table if not exists public.order_items (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  order_id bigint references public.orders not null,
  product_id bigint references public.products not null,
  quantity integer not null,
  price numeric not null -- Price at time of purchase
);

alter table public.order_items enable row level security;

drop policy if exists "Users can view their own order items." on order_items;
create policy "Users can view their own order items."
  on order_items for select
  using ( exists ( select 1 from orders where id = order_items.order_id and user_id = auth.uid() ) );

drop policy if exists "Users can insert their own order items." on order_items;
create policy "Users can insert their own order items."
  on order_items for insert
  with check ( exists ( select 1 from orders where id = order_id and user_id = auth.uid() ) );

-- Create storage buckets
insert into storage.buckets (id, name, public) 
values ('products', 'products', true)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public) 
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

-- Storage policies
drop policy if exists "Anyone can view product images" on storage.objects;
create policy "Anyone can view product images"
  on storage.objects for select
  using ( bucket_id = 'products' );

drop policy if exists "Admins can upload product images" on storage.objects;
create policy "Admins can upload product images"
  on storage.objects for insert
  with check ( bucket_id = 'products' and public.is_admin() );

-- Create cart_items table
create table if not exists public.cart_items (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references public.profiles(id) not null,
  product_id bigint references public.products not null,
  quantity integer default 1,
  unique(user_id, product_id)
);

alter table public.cart_items enable row level security;

drop policy if exists "Users can view their own cart items." on cart_items;
create policy "Users can view their own cart items."
  on cart_items for select
  using ( auth.uid() = user_id );

drop policy if exists "Users can insert their own cart items." on cart_items;
create policy "Users can insert their own cart items."
  on cart_items for insert
  with check ( auth.uid() = user_id );

drop policy if exists "Users can update their own cart items." on cart_items;
create policy "Users can update their own cart items."
  on cart_items for update
  using ( auth.uid() = user_id );

drop policy if exists "Users can delete their own cart items." on cart_items;
create policy "Users can delete their own cart items."
  on cart_items for delete
  using ( auth.uid() = user_id );


-- Create wishlist table
create table if not exists public.wishlist (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references public.profiles(id) not null,
  product_id bigint references public.products not null,
  unique(user_id, product_id)
);

alter table public.wishlist enable row level security;

drop policy if exists "Users can view their own wishlist." on wishlist;
create policy "Users can view their own wishlist."
  on wishlist for select
  using ( auth.uid() = user_id );

drop policy if exists "Users can insert their own wishlist." on wishlist;
create policy "Users can insert their own wishlist."
  on wishlist for insert
  with check ( auth.uid() = user_id );

drop policy if exists "Users can delete their own wishlist." on wishlist;
create policy "Users can delete their own wishlist."
  on wishlist for delete
  using ( auth.uid() = user_id );



-- Create reviews table
create table if not exists public.reviews (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references public.profiles(id) not null,
  product_id bigint references public.products not null,
  rating integer not null check (rating >= 1 and rating <= 5),
  comment text,
  unique(user_id, product_id)
);

alter table public.reviews enable row level security;

drop policy if exists "Reviews are viewable by everyone." on reviews;
create policy "Reviews are viewable by everyone."
  on reviews for select
  using ( true );

drop policy if exists "Users can insert their own reviews." on reviews;
create policy "Users can insert their own reviews."
  on reviews for insert
  with check ( auth.uid() = user_id );

drop policy if exists "Users can update their own reviews." on reviews;
create policy "Users can update their own reviews."
  on reviews for update
  using ( auth.uid() = user_id );

drop policy if exists "Users can delete their own reviews." on reviews;
create policy "Users can delete their own reviews."
  on reviews for delete
  using ( auth.uid() = user_id );

-- Function to update product rating when a review is added/updated/deleted
create or replace function public.handle_review_change()
returns trigger
language plpgsql
security definer
as $$
begin
  update public.products
  set 
    rating = (select coalesce(avg(rating), 0) from public.reviews where product_id = coalesce(new.product_id, old.product_id)),
    review_count = (select count(*) from public.reviews where product_id = coalesce(new.product_id, old.product_id))
  where id = coalesce(new.product_id, old.product_id);
  return null;
end;
$$;

drop trigger if exists on_review_change on public.reviews;
create trigger on_review_change
  after insert or update or delete on public.reviews
  for each row execute function public.handle_review_change();
-- Function to delete the current user's account and all related data
create or replace function public.delete_account()
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  uid uuid;
begin
  uid := auth.uid();
  
  if uid is null then
    raise exception 'Not authenticated';
  end if;

  -- Delete related data (Cascade manually to be safe)
  delete from public.cart_items where user_id = uid;
  delete from public.wishlist where user_id = uid;
  delete from public.reviews where user_id = uid;
  
  -- Delete items in orders belonging to user
  delete from public.order_items 
  where order_id in (select id from public.orders where user_id = uid);
  
  -- Delete orders
  delete from public.orders where user_id = uid;
  
  -- Delete profile
  delete from public.profiles where id = uid;
  
  -- Delete from auth.users (This works if the postgres role has permission, otherwise it might fail)
  delete from auth.users where id = uid;
end;
$$;

-- Enable Realtime for products
drop publication if exists supabase_realtime;
create publication supabase_realtime for table products, orders, order_items;